#include <utility/ostream.h>

using namespace EPOS;

OStream cout;

// Radio registers
enum
{
    FRMFILT0  = 0x40088600,
	FRMCTRL0  = 0x40088624,
	FRMCTRL1  = 0x40088628,
	FREQCTRL  = 0x4008863C,
    FSMSTAT1  = 0x4008864C,
    FIFOPCTRL = 0x40088650,
    RXFIFOCNT = 0x4008866C,
    TXFIFOCNT = 0x40088670,
	CSPT      = 0x40088794,
	RFDATA    = 0x40088828,
    RFERRF    = 0x4008882C,
    RFIRQF1   = 0x40088830,        
	RFST      = 0x40088838,
};

// Radio commands
enum
{
	STXON     = 0xd9,
	SFLUSHTX  = 0xde,
	ISRXON    = 0xe3,
	ISTXON    = 0xe9,
    ISFLUSHRX = 0xed,
	ISFLUSHTX = 0xee,
    ISRFOFF   = 0xef,
	ISCLEAR   = 0xff,
};

// SYS_CTRL registers
enum
{
    RCGCRFC = 0x400D20A8
};

// Useful bits in RFCORE_XREG_FRMFILT0
enum
{
    FRAME_FILTER_EN = 1 << 0,
};
// Useful bits in RFCORE_XREG_FSMSTAT1
enum
{
    FIFOP = 1 << 6,
};
// Useful bits in RFCORE_SFR_RFIRQF1
enum
{
    TXDONE = 1 << 1,
};

void config_radio(int channel = 11)
{
	volatile unsigned int * frmfilt0 = reinterpret_cast<volatile unsigned int *>(FRMFILT0);
	volatile unsigned int * rfirqf1 = reinterpret_cast<volatile unsigned int *>(RFIRQF1);
	volatile unsigned int * frmctrl0 = reinterpret_cast<volatile unsigned int *>(FRMCTRL0);
	volatile unsigned int * frmctrl1 = reinterpret_cast<volatile unsigned int *>(FRMCTRL1);
	volatile unsigned int * fifopctrl = reinterpret_cast<volatile unsigned int *>(FIFOPCTRL);
	volatile unsigned int * rcgcrfc = reinterpret_cast<volatile unsigned int *>(RCGCRFC);
	volatile unsigned int * freqctrl = reinterpret_cast<volatile unsigned int *>(FREQCTRL);
	volatile unsigned int * cspt = reinterpret_cast<volatile unsigned int *>(CSPT);

    // Disable clock to the RF CORE module
    *rcgcrfc = 0x00; 

    // Disable frame filtering
    *frmfilt0 &= ~FRAME_FILTER_EN;

    // Set FIFOP threshold to maximum
    *fifopctrl = 0xff;

	// Enable auto-CRC
	*frmctrl0 = 0x40;

	// Do not enter receive mode after TX
	*frmctrl1 = 0x00;

	/*
	   The carrier frequency is set by programming the 7-bit frequency word in the FREQ[6:0] bits of the
	   FREQCTRL register. Changes take effect after the next recalibration. Carrier frequencies in the range
	   from 2394 to 2507 MHz are supported. The carrier frequency f C , in MHz, is given by f C = (2394 +
	   FREQCTRL.FREQ[6:0]) MHz, and is programmable in 1-MHz steps.
	   IEEE 802.15.4-2006 specifies 16 channels within the 2.4-GHz band. These channels are numbered 11
	   through 26 and are 5 MHz apart. The RF frequency of channel k is given by Equation 1.
	   f c = 2405 + 5(k –11) [MHz] k [11, 26]
	   (1)
	   For operation in channel k, the FREQCTRL.FREQ register should therefore be set to
	   FREQCTRL.FREQ = 11 + 5 (k – 11).
    */
    int freq = 11+5*(channel-11);
	*freqctrl = freq;

	// Disable counting of MAC overflows
	*cspt = 0xff;

    // Clear interrupts
    *rfirqf1 = 0;

    // Enable clock to the RF CORE module
    *rcgcrfc = 0x01; 
}

// Block until data_len bytes are received, then copy them to data and return
// return number of payload bytes received
int receive(char * data, char data_len)
{
	volatile unsigned int * rfst = reinterpret_cast<volatile unsigned int *>(RFST);
	volatile unsigned int * fsmstat1 = reinterpret_cast<volatile unsigned int *>(FSMSTAT1);
	volatile unsigned int * rfdata = reinterpret_cast<volatile unsigned int *>(RFDATA);
	volatile unsigned int * rxfifocnt = reinterpret_cast<volatile unsigned int *>(RXFIFOCNT);

    // Clear RXFIFO
	*rfst = ISFLUSHRX;

    // Start listening
	*rfst = ISRXON;

    // Wait for a complete frame to be received
    while(!((*fsmstat1) & FIFOP));
    
    // Stop listening
	*rfst = ISRFOFF;

    // Read length field
    auto cnt = *rfdata;
    // Copy data
    for(int i=0;(i<cnt-2) && (i<data_len);i++)
        data[i] = *rfdata;

    return cnt-2; // Remove FCS
}

// Immediately send a message using the radio.
// data is expected to hold only the MAC header and MAC payload.
void send(const char * data, char data_len)
{
	volatile unsigned int * rfst = reinterpret_cast<volatile unsigned int *>(RFST);
	volatile unsigned int * rfirqf1 = reinterpret_cast<volatile unsigned int *>(RFIRQF1);
	volatile unsigned int * rferrf = reinterpret_cast<volatile unsigned int *>(RFERRF);
	volatile unsigned int * txfifocnt = reinterpret_cast<volatile unsigned int *>(TXFIFOCNT);
	volatile unsigned int * rfdata = reinterpret_cast<volatile unsigned int *>(RFDATA);

	// Clear TXFIFO
	*rfst = ISFLUSHTX;

	// Write a frame for transmission.
	// FCS is set to be generated by the hardware.
    // First field is frame length. +2 to accommodate FCS.
	*rfdata = data_len+2;
	// Data written to RFDATA register automatically end up in TXFIFO
	for(int i=0;i<data_len;i++)
		*rfdata = data[i];

	// Issue the send command
	*rfst = ISTXON;

    // Wait for sending to finish
    while(!((*rfirqf1) & TXDONE));

    // Clear TXDONE interrupt
    *rfirqf1 &= ~TXDONE;
}

void receiver()
{
    const unsigned int data_max = 128;
    char data[data_max];

    config_radio();
    while(1)
    {
        cout << "Receiving..." << endl;
        int r = receive(data, data_max);
        cout << "Received " << r << " bytes: " << data << endl;
    }
}

void sender()
{
    const char data[] = "Hello, World!";

    config_radio();
    while(1)
    {
        cout << "Sending..." << endl;
        send(data, sizeof(data));
        cout << "Sent" << endl;
    }
}

int main()
{
//    sender();
    receiver();
    return 0;
}
